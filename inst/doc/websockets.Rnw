% \VignetteIndexEntry{websockets Manual}
% \VignetteDepends{websockets}
% \VignettePackage{websockets}
\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage[pdftex]{graphicx}
\usepackage{color}
\usepackage{xspace}
\usepackage{fancyvrb}
\usepackage{fancyhdr}
\usepackage[
     colorlinks=true,
     linkcolor=blue,
     citecolor=blue,
     urlcolor=blue]
     {hyperref}
\usepackage{lscape}
\usepackage{Sweave}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{mdwlist}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% define new colors for use
\definecolor{darkgreen}{rgb}{0,0.6,0}
\definecolor{darkred}{rgb}{0.6,0.0,0}
\definecolor{lightbrown}{rgb}{1,0.9,0.8}
\definecolor{brown}{rgb}{0.6,0.3,0.3}
\definecolor{darkblue}{rgb}{0,0,0.8}
\definecolor{darkmagenta}{rgb}{0.5,0,0.5}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\bld}[1]{\mbox{\boldmath $#1$}}
\newcommand{\shell}[1]{\mbox{$#1$}}
\renewcommand{\vec}[1]{\mbox{\bf {#1}}}
\newcommand{\ReallySmallSpacing}{\renewcommand{\baselinestretch}{.6}\Large\normalsize}
\newcommand{\SmallSpacing}{\renewcommand{\baselinestretch}{1.1}\Large\normalsize}
\def\tm{\leavevmode\hbox{$\rm {}^{TM}$}}


\setlength{\oddsidemargin}{-.25 truein}
\setlength{\evensidemargin}{0truein}
\setlength{\topmargin}{-0.2truein}
\setlength{\textwidth}{7 truein}
\setlength{\textheight}{8.5 truein}
\setlength{\parindent}{0.20truein}
\setlength{\parskip}{0.10truein}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagestyle{fancy}
\lhead{}
\chead{The {\tt websockets} Package}
\rhead{}
\lfoot{}
\cfoot{}
\rfoot{\thepage}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{The {\tt websockets} Package}
\author{Bryan W. Lewis \\ 
blewis@illposed.net}

\begin{document}

\maketitle

\thispagestyle{empty}

\section{Introduction}

The HTML 5 websocket API is a modern socket-like communication protocol for the
web. The {\tt websockets} package is a native websocket implementation
for R that supports most of the draft IETF protocols in use by web browsers.
The {\tt websockets} package is especially well-suited to interaction between R
and web scripting languages like Javascript.  Multiple simultaneous websocket
server and client connections are supported.

The library has few external dependencies and, written mostly in R, is easily
portable.  More significantly, {\tt websockets} lets Javascript and other
scripts embedded in web pages directly interact with R, bypassing traditional
middleware layers like .NET, Java, and web servers normally used for such
interaction. In some cases, websockets may make much more efficient use of
networks than Ajax-like schemes for interacting with clients over web protocls.

\section{Using {\tt websockets} as a server, step by step}

The {\tt websockets} package includes a server function that can initiate and
respond to websocket and HTTP events over a network connection
(websockets are an extension of standard HTTP).
All R/Websocket server applications share the following basic recpie:
\begin{enumerate}
\item Load the library.
\item Initialize a websocket server with {\tt create\_server}.
\item Set callback functions that will respond to desired events.
\item Service the server's socket interface with {\tt service}, often in an event loop.
\item Shutdown the server and delete the server environment when done.
\end{enumerate}
We outline the steps with examples below.

\subsection{Load the library}
\begin{lstlisting}
library('websockets')
\end{lstlisting}
The library depends on the {\tt caTools} and a recent version of the 
{\tt digest} package.  It suggests that the {\tt RJSONIO} library be installed,
as it is quite useful to have available when interacting with Javascript.

\subsection{Initialize a websocket server with {\tt create\_server}}
The R/Websocket service is initialized by a call to the
{\tt create\_server} function. (The initialization method called
{\tt createContext} from older versions of the package is still supported.)
The function takes two arguments, a network port
to listen on, and an optional function closure to service standard
HTTP requests (described in greater detail below).
The {\tt create\_server} function returns an environment
that stores data associated with the newly created server.
``Callback'' functions may be assigned that respond
to websocket events. Here is an example that creates a websocket server
on the default port of 7681:
\begin{lstlisting}
server = create_server()
\end{lstlisting}

The websocket server will respond directly to any websocket client request.
For convenience, the server may optionally also service basic HTML reuests.  For
example, the basic package demo available from {\tt demo('websockets')} serves
clients the file {\tt basic.html} located in the package installation path.
However, serving HTML web pages is not the primary function of the {\tt
websockets} library--see the
\href{http://cran.r-project.org/web/packages/Rook/}{Rook} package for that. 

\subsection{Set callback functions to respond to events}
Clients may connect to the websocket service immediately after the server is
initialized. The server may write data to or close client connections at any
time.  However, one must define functions to respond to incoming client events.

A server supports the following incoming events:
\begin{enumerate}
\item[] {\tt established}: Occurs when a websocket client connection is
successfully negotiated.
\item[] {\tt closed}: Occurs when a client websocket connection has been closed.
\item[] {\tt receive}: Occurs when data is received from a connection.
\end{enumerate}
R functions may be defined to handle some, all, or none of the above event
types. Such functions are termed ``callbacks.''

The {\tt set\_callback} function may be used to define a callback function in
the server environment returned by {\tt create\_server}. (It
simply assigns the functions in that environment.)

The {\tt receive} callback function 
must take precisely three parameters that are filled in by the library
with values corresponding to an event when invoking a callback function.
The required parameters are:
\begin{enumerate}
\item {\tt DATA}: A RAW vector that holds any incoming data associated
with the event. It may be of length zero if the event does not have any
data to report.
\item {\tt WS}: The websocket client associated with the event, represented
as an R list.
\item {\tt HEADER}: Header data returned by newer protocol versions, or
NULL for protocol version 00.
\end{enumerate}

The {\tt closed} and {\tt receive} function must each take one argument:
\begin{enumerate}
\item {\tt WS}: The websocket client associated with the event, represented
as an R list.
\end{enumerate}

The example function below sends a message to each newly-established
connection:
\begin{lstlisting}
f = function(WS) {
  websocket_write("Hello there!", WS)
}
set_callback("established", f, server)
\end{lstlisting}

Here is an example function callback that receives data from a client
connection and simply echoes it back:
\begin{lstlisting}
g = function(DATA, WS, ...) {
  websocket_write(DATA, WS)
}
setCallback("receive", g, server)
\end{lstlisting}

\subsection{Accept requests from web clients}
Javascript and other web script clients can very easily interact with the
R {\tt websockets} library directly from most browsers. The listing below
presents a very basic example--see the demo scripts in the
the package installation path for more complete examples.
\begin{lstlisting}
<html><body>
<script>
socket = new WebSocket("ws://localhost:7681", "chat");
try {
  socket.onmessage = function got_packet(msg) {
    document.getElementById("output").textContent = msg.data;
  } 
catch(ex) {document.getElementById("output").textContent = "Error: " + ex;}
</script>
<div id="output"> SOCKET DATA APPEARS HERE </div>
</body></html>
\end{lstlisting}
{\bf Note: The {\tt websockets} package presently ignores the
sub-protocol (``chat'' in the above example). Future versions of the
package may require specific sub-protocols.}

\subsection{Service the socket interface with {\tt service}}

Websocket events are placed in a queue. The {\tt service} function
processes events in the queue on a first-come, first-served basis.
The {\tt service} function processes each event by invoking the
appropriate callback function.
It returns after a configurable time out if there are no events to service.
Events may be processed indefinitely by evaluating the {\tt service} function
in a loop, for example:
\begin{lstlisting}
while(TRUE)
{
  service(server)
}
\end{lstlisting}
The {\tt service} function timeout value
prevents the R session from spinning and consuming lots of CPU time. See the
{\tt service} help page for more information.

\subsection{Sending data to clients}
The {\tt websocket\_write} and {\tt websocket\_broadcast} functions may
be used to send data to clients. The {\tt websocket\_broadcast} function
emulates a broadcast by sending data in a loop to all connected websocket
clients associated with the specified server. 

The {\tt websocket\_write} function may be used at any time to send data
to a specific websocket client. Each websocket server environment returned
by the {\tt create\_server} function maintains a list of connected client
sockets in the variable {\tt client\_sockets}. Each client socket is in
turn represented by an R list. The following example assumes that the
{\tt server} environment has been initialized and contains a single
client:
\begin{lstlisting}
websocket_write("Hello", server$client_sockets[[1]])
\end{lstlisting}
{\bf Note the use of the double bracket indexing operator to select a single
list element from the {\tt client\_sockets} list.}

\subsection{Close the server when done}
Servers should be closed when done as follows:
\begin{lstlisting}
websocket_close(server)
\end{lstlisting}

\subsection{HTTP convenience functions}

The {\tt websockets} package includes two convenience function closures for
servicing basic HTTP requests: {\tt static\_file\_service} and {\tt
static\_text\_service}. The functions take either a file name or text string
that contains an HTML web page, respectively, and issue a well-formed HTTP 200
response to the requesting client. They are intended to be used in the
{\tt webpage} argument to the {\tt create\_server} function.
The following example defines a basic web page in a string variable:
\begin{lstlisting}
content='<html><body>
  <script>
  socket = new WebSocket("ws://localhost:7681", "chat");
  try {
    socket.onmessage = function got_packet(msg) {
      document.getElementById("output").textContent = msg.data;
    } 
  catch(ex) {document.getElementById("output").textContent = "Error: " + ex;}
  </script>
  <div id="output"> SOCKET DATA APPEARS HERE </div>
  </body></html>
'

server = create_server(webpage=static_text_service(content))
\end{lstlisting}

The web page text will be issued to any client making an HTTP GET request.  To
serve content from files instead, use the {\tt static\_file\_service} function.
Additionally, the {\tt static\_file\_service} function checks to see if the
file has been updated and always uses a fresh version.

Note that both convenience functions mostly ignore the GET RESOURCE and 
all other GET request parameters. The always only return the specified HTML
content. POST requests are always ignored by the websocket server.
Users are free to define their own function closures to use
instead, which may be more full-featured. Use the existing functions
as a guide. If you really need a full-featured HTTP service,
we reccommend using the 
\href{http://cran.r-project.org/web/packages/Rook}{Rook} package
instead.


\section{Using {\tt websockets} as a client}
The {\tt websocket} function provides an R client interface. 

FINISH WRITING ME

\section{Tips and miscellaneous notes}
We present a few more advanced and other miscellaneous notes in this
section.
\subsection{Binary data}
Binary data is supported by IETF websocket protocol versions greater than
00. The {\tt websockets} package supports the older 00 protocol with
ASCII-only data, as well as binary data transfers with newer clients.

JSON is probably a good choice to use when interacting with Javascript
and the data size is not too large. The suggested {\tt RJSONIO} package
helps map many native R objects to JSON and vice versa, greatly
facilitating interaction between R and Javascript. But, JSON data is
transferred as characters, which may incur performance and in some cases
numeric issues.

\end{document}
